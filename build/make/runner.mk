IMAGE_BASENAME = registries-operator
IMAGE_NAME     = opensuse/$(IMAGE_BASENAME)
IMAGE_TAR_GZ   = $(IMAGE_BASENAME)-latest.tar.gz
IMAGE_DEPS     = $(REGS_OPER_EXE) Dockerfile

# sudo command (and version passing env vars)
SUDO = sudo
SUDO_E = $(SUDO) -E

# the default kubeconfig program generated by kubeadm (used for running things locally)
KUBECONFIG = /etc/kubernetes/admin.conf
KUBECTL    = kubectl --kubeconfig=$(KUBECONFIG)

# increase to 8 for detailed kubeadm logs...
# Example: make local-run VERBOSE_LEVEL=8
VERBOSE_LEVEL = 5

CONTAINER_VOLUMES = \
	-v /sys/fs/cgroup:/sys/fs/cgroup \
	-v /var/run:/var/run

.PHONY: $(KUBECONFIG)
$(KUBECONFIG):
	@[ -r $(KUBECONFIG) ] || (echo ">>> Making $(KUBECONFIG) readable..." ; $(SUDO_E) chmod 644 $(KUBECONFIG) ; )
	@echo ">>> Using $(KUBECONFIG)..."

#############################################################
# Some simple run targets
# (for testing things locally)
#############################################################

local-$(IMAGE_TAR_GZ): $(REG_OPER_EXE)
	@echo ">>> Creating Docker image (Local build)..."
	docker build -f Dockerfile.local \
		--build-arg BUILT_EXE=$(REGS_OPER_EXE) \
		-t $(IMAGE_NAME):latest .
	@echo ">>> Creating tar for image (Local build)"
	docker save $(IMAGE_NAME):latest | gzip > local-$(IMAGE_TAR_GZ)

$(IMAGE_TAR_GZ):
	@echo ">>> Creating Docker image..."
	docker build -t $(IMAGE_NAME):latest .
	@echo ">>> Creating tar for image..."
	docker save $(IMAGE_NAME):latest | gzip > $(IMAGE_TAR_GZ)

# assuming the k8s cluster is accessed with $(KUBECONFIG),
# deploy the registries-operator manifest file in this cluster.
local-deploy: $(REGS_DEPLOY) $(KUBECONFIG)
	@echo ">>> (Re)deploying..."
	@echo ">>> Deleting any previous resources..."
	-@$(KUBECTL) get ldapconnectors -o jsonpath="{..metadata.name}" | \
		xargs -r $(KUBECTL) delete --all=true ldapconnector 2>/dev/null
	-@$(KUBECTL) get dexconfigurations -o jsonpath="{..metadata.name}" | \
		xargs -r $(KUBECTL) delete --all=true dexconfiguration 2>/dev/null
	@sleep 30
	-@$(KUBECTL) delete --all=true --cascade=true -f $(REGS_DEPLOY) 2>/dev/null
	@echo ">>> Loading manifests..."
	$(KUBECTL) apply -f $(REGS_DEPLOY)

clean-local-deploy: $(KUBECONFIG)
	@make manifests
	@echo ">>> Uninstalling manifests..."
	$(KUBECTL) delete -f $(REGS_DEPLOY)

# Usage:
# - Run it locally:
#   make local-run VERBOSE_LEVEL=5
# - Start a Deployment with the manager:
#   make local-run EXTRA_ARGS="--"
#
local-run: $(REGS_OPER_EXE) $(KUBECONFIG)
	@echo ">>> Loading stuff with kubectl apply"
	@for f in config/sas/*.yaml config/crds/*.yaml ; do $(KUBECTL) apply -f $$f ; done
	@sleep 5
	@echo ">>> Running $(REGS_OPER_EXE)"
	$(REGS_OPER_EXE) manager \
		-v $(VERBOSE_LEVEL) \
		--kubeconfig $(KUBECONFIG) \
		$(EXTRA_ARGS)

docker-run: $(IMAGE_TAR_GZ)
	@echo ">>> Running $(IMAGE_NAME):latest in the local Docker"
	docker run -it --rm \
		--privileged=true \
		--net=host \
		--security-opt seccomp:unconfined \
		--cap-add=SYS_ADMIN \
		--name=$(IMAGE_BASENAME) \
		$(CONTAINER_VOLUMES) \
		$(IMAGE_NAME):latest $(EXTRA_ARGS)

docker-image-local: local-$(IMAGE_TAR_GZ)

docker-image: $(IMAGE_TAR_GZ)
docker-image-clean:
	-[ -f $(IMAGE_TAR_GZ) ] && docker rmi $(IMAGE_NAME)
	rm -f $(IMAGE_TAR_GZ)
